---
layout: post
title:  基础算法
category: 算法
description: 基础算法
---

## 单调队列
一个queue，从front到back单调递减，来自题[239](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)，不必关心队列长度:frog:，只需在所有数据上去维护一个队列，然后边遍历边更新结果
```c++
std::deque<int> q;
for(int i = 0; i < len; i++){
    //1.入队
    while(!q.empty() && nums[q.back()] <= nums[i])
        q.pop_back();//要把nums[i]放到队列里需要把比他小的都拿走，保证单调性，同时这些没有机会成为最大值，
    q.push_back(i);
    //2.出队，出队列只有一种情况，就是front已经不在这个窗口里面了
    if(i - q.front() + 1 > k)//下标作差+1就是长度
        q.pop_front();
    //3.记录结果
    if(i + 1> k)
        res.push_back(nums[q.front()]);
}
```

入队是每个元素都会做，出队只关心front，只有它才是结果，front出队只有一种情况，就是它的下标q.front()与当前下标i的差超过了k :forg:  


## 滑动窗口

## 堆
堆是满足根节点的值大于左右节点的二叉树，C++中有优先队列可以用，具体实现的分为以下几部  
调整下标为index的子树，使index的值下沉放到合适的位置
```c++
//假定除了index外，它所有子树都是满足堆性质的
void heapify(int index, int size){
    int left = index*2+1, right = index*2+2, largest = index;
    //找到根节点左右节点中最大值，并交换到根节点
    if(left < size && nums[left] > nums[largest]){
        largest = left;
    }
    if(right < size && nums[right] > nums[largest]){
        largest = right;
    }
    if(largest != index){
        swap(nums[largest], nums[index]);
        heapify(largest, size);
    }
}
//
void buildHeap(){
    for(int i = size/2 - 1; i>=0; i--){
        heapify(i, size);
    }
}
//去掉最大值，然后调整堆
int removeHead(){
    int maxVal = heap[0];
    heap[0] = heap.back();
    heap.pop_back();
    heapify(0, heap.size());
    return maxVal;
}
```
建堆的时候从下到上调用heapify，从最后一个**非叶子结点**开始，非叶子节点至少要有一个左子节点，也就是2*i+1，长度为n，所以i就是从(n-1)/2开始，跟n/2-1也是等价的，因为heapify的调整是递归的:frog:

如果要插入元素要实现从低到上调整的heapifyUp
```c++
    void heapifyUp(int index) {
        int parent = (index - 1) / 2;
        while (index > 0 && heap[index] > heap[parent]) { // for max heap (use < for min heap)
            std::swap(heap[index], heap[parent]);
            index = parent;
            parent = (index - 1) / 2;
        }
    }
```

## 桶排序
O(n)的排序，但是好的办法总是有限制的，比如数据不能太大，假定给定数组内元素在[-1e4,1e4]之间，把数组值映射成桶下标
```c++
int bucket[2e4+1] = {};
for(auto n:nums){
    bucket[n+1e4]++;
}
//如果要找第k大的数
for(int i = 2e4; i>=0; i--){
    if(bucket[i]==0) continue;
    if(k-bucket[i] > 0) k -= bucket[i];
    else return i-1e4;
}
```

## 二分法
二分的适用前提是数据是有序的，这样才能排除另外一半的数据，需要注意的是相等的情况下，是更新左端点还是右端点

## 前缀和
前缀和跟数列的前n项和思想一样，求中间一段连续的数据的和可以用preSum[i]-preSum[j]来实现，一般看到“子数组”这种要考虑使用前缀和优化  
题[17.05](https://leetcode.cn/problems/find-longest-subarray-lcci/description/)

前缀和一般的计算方式是：对于数组nums，`s[i+1] = s[i] + nums[i]`，因此，子数组`[left, right)`的和就是  `nums[right]-nums[left]`
```c++
vector<int> s(nums.size()+1, 0);//这里目的是让s[0]=0
for(int i = 0; i < nums.size(); i++){
    s[i+1] = s[i] + nums[i];
}
```
那么这个问题就转化成了，“在数组s中，找到值相同的两个数中距离最远的那两个的下标”，用哈希表记录第一次遇到的数和下标就可以了；

这里还有个优化，判断一个字符是数字还是字母
```c++
(c >> 6 & 1) * 2 - 1
```
ASCII码二进制，字母是01xxxxxx，数字是0011xxxx，所以右移6位如果是字母就是01，是数字就是00，*2-1是为了转成-1，1，不然这里的写法是if-else，这里大佬考虑到了分支预测器……，

## DP
DP其实是暴力枚举的优化，如果“当前的状态受到前面的状态的影响”，也就是数列中的递推关系`a[n+1] = f(a[n])`存在

每日一题碰到的比较典型的问题[3148](https://leetcode.cn/problems/maximum-difference-score-in-a-grid/description/?envType=daily-question&envId=2024-08-15)  
这个问题等价于找到以(i,j)为顶点的矩形中除去(i,j)之外的最大值，很明显，(i,j)最大值，也就是`max{(i+1,j), (i,j+1), grid[i][j]}`，所以可以定义dp[i][j]是以(i,j)为左上顶点的矩形的最大值，  
`dp[i][j] = max{dp[i+1][j], dp[i][j+1], grid[i][j]}`  
从右下角开始遍历，这里的实现有些许麻烦:frog:，需要确定dp[i][j]是不是grid[i][j]，如果是的话差值要用`max{dp[i+1][j], dp[i][j+1]}`作为最大值，实现上有些麻烦……

## DFS
二叉树深度最大最小值，最大值是到叶子节点的个数，碰到左/右子树为空就可以舍弃这个分支了，所以可以直接`return max(maxdepth(root->left), maxdepth(root->right))`，如果是最小深度，碰到左/右分支为空是不能舍弃这个分支的，因为最小值有可能出现在它下面的叶子节点
[111](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)和[104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

深度优先的写法，标记每一层的深度，维护全局结果ans
```c++
class Solution {
private:
    int ans = 1e5+1;
public:
    void dfs(TreeNode* root, int depth){
        if(root==nullptr) return;
        depth++;
        if(root->left==nullptr && root->right == nullptr){
            ans = min(ans, depth);
            return;
        }
        dfs(root->left, depth);
        dfs(root->right, depth);
    }
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        dfs(root, 0);
        return ans;
    }
};
```
这里面depth要作为**值传递**，因为每一层都要有自己的depth，而ans其实可以作为dfs参数中的**引用**来传递，维护全局的ans