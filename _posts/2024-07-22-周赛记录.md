---
layout: post
title:  周赛
category: 算法
description: 记录一下周赛恢复性训练
---

# 407场2024.7.21
## 位运算
此题很简单:frog:，但是也是工作中最有可能碰到的位运算，所以记录一下  
[3226](https://leetcode.cn/contest/weekly-contest-407/problems/number-of-bit-changes-to-make-two-integers-equal/)  有两个正整数n,k，通过把1->0能否使n->k，能的话计算1->0的更改次数  
比较n和k当中不同的位获取其标识，**异或** n^k，不同的位为1，若n->k能成功，则n & ~(n ^ k)要与k相等，需要改变的次数就是n ^ k中1的个数
```c++
if((n & ~(n^k)) != k) return -1;
else 
//计算二进制中1的个数
while(n){
    n &= (n-1);
    count ++;
}
```
这个计算二进制中'1'的个数还是挺有意思的:frog:

## 贪心
[3228](https://leetcode.cn/contest/weekly-contest-407/problems/maximum-number-of-operations-to-move-ones-to-the-end/)
将'1'移动到末尾的最大操作次数  
最初以为是双指针，记录“连续的1”的个数，快指针碰到'10'之后就更新这段连续1的长度，然后更新慢指针，但题目要求最大的次数，也就是每次碰到'10'需要把前面的所有'1'都再移动一次，所以只需要一次遍历，记录1的个数，然后碰到'10'就更新结果
```c++
for (int i = 0; i < s.size(); i++){
    //后面跟了0的1
    if(s[i]=='1'&&s[i+1]=='0'){
        cnt ++;
        ret += cnt;
    }
    //正常的1
    else if(s[i]=='1'){
        cnt ++;
    }
}
```